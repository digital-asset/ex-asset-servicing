module DA.Finance.Distribution.Distribution where

import DA.Finance.Asset
import DA.Finance.Types
import DA.Foldable (forA_)
import DA.List (head)
import DA.Next.Set (empty)

template DistributionRequest
  with
    depository : Party
    issuer : Party
    agent : Party
    label : Text
    asset : Asset
    issuerAccountAtAgent : Account
  where
    signatory depository, issuer
    observer agent

    controller agent can
      nonconsuming RequestSubscription : [ContractId SubscriptionRequest]
        with
          investors : [Party]
          price : Asset
        do
          mapA (\investor -> create SubscriptionRequest with ..) investors

    controller agent can
      nonconsuming InstructDistribution : [ContractId SettlementInstruction]
        with
          subscriptionResponseCids : [ContractId SubscriptionResponse]
          issuanceDepositCid : ContractId AssetDeposit
          agentAccountAtAgent : Account
          agentAccountAtDepository : Account
        do
          subscriptionResponses <- mapA fetch subscriptionResponseCids
          forA_ subscriptionResponseCids (`exercise` DeleteSubscriptionResponse)

          let
            quantities = map (.quantity) subscriptionResponses
            totalQuantity = sum quantities
            investors = map (.investor) subscriptionResponses
          depositCid <- create AssetDeposit with account = agentAccountAtAgent; observers = empty; asset = asset with quantity = totalQuantity
          subscribedDepositCid <- head <$> exercise issuanceDepositCid AssetDeposit_Split with quantities = [ totalQuantity ]
          subscribedDeposit <- fetch subscribedDepositCid
          agentDepositCids <- exercise depositCid AssetDeposit_Split with quantities
          let
            responseDepositPairs = zip subscriptionResponses agentDepositCids
            createSettlementInstructions ((sr, agentDepositCid) : (SubscriptionResponse, ContractId AssetDeposit)) =
              do
                investorDeposit <- fetch sr.depositCid
                agentDeposit <- fetch agentDepositCid
                assertMsg "Investor deposit doesn't match price asset" $ investorDeposit.asset.id == sr.price.id
                assertMsg "Investor deposit doesn't match cost" $ investorDeposit.asset.quantity == sr.quantity * sr.price.quantity
                let
                  delivery = SettlementInstruction with fromDeposit = agentDeposit; fromDepositCid = agentDepositCid; toAccount = investorDeposit.account; ..
                  payment = SettlementInstruction with fromDeposit = investorDeposit; fromDepositCid = sr.depositCid; toAccount = issuerAccountAtAgent; ..
                pure [ delivery, payment ]
            distributionInstruction = SettlementInstruction with fromDeposit = subscribedDeposit; fromDepositCid = subscribedDepositCid; toAccount = agentAccountAtDepository; ..
          settlementInstructions <- concat <$> mapA createSettlementInstructions responseDepositPairs
          mapA create (distributionInstruction :: settlementInstructions)

template SubscriptionRequest
  with
    depository : Party
    issuer : Party
    agent : Party
    investor : Party
    label : Text
    asset : Asset
    price : Asset
  where
    signatory depository, issuer, agent
    observer investor

    controller investor can
      RespondSubscription : ContractId SubscriptionResponse
        with
          quantity : Decimal
          depositCid : ContractId AssetDeposit
        do
          create SubscriptionResponse with ..

template SubscriptionResponse
  with
    depository : Party
    issuer : Party
    agent : Party
    investor : Party
    label : Text
    asset : Asset
    price : Asset
    quantity : Decimal
    depositCid : ContractId AssetDeposit
  where
    signatory depository, issuer, agent, investor

    controller depository, agent can
      DeleteSubscriptionResponse : ()
        do pure ()

template SettlementInstruction
  with
    depository : Party
    issuer : Party
    agent : Party
    label : Text
    fromDeposit : AssetDeposit
    fromDepositCid : ContractId AssetDeposit
    toAccount : Account
  where
    signatory depository, issuer, agent

    controller depository can
      Settle : ContractId AssetDeposit
        do
          fromDeposit <- fetch fromDepositCid
          archive fromDepositCid
          create fromDeposit with account = toAccount
